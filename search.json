[{"title":"🖊️ 计算机学院 高级数据结构 （Advanced Data Structure）","url":"/2024/02/26/ads/","content":"Basic info课程名：高级数据结构 （Advanced Data Structure）\n主讲教师： $\\mathbf{A.P.}$ $\\mathrm{Yao-Xiang\\;Ding}$\nE-mail：$\\mathrm{yxding@zju.edu.cn}$\n分数占比：\n\nAssignment $10\\%$\n讨论 $10\\%$\nResearch Project $30\\%$\nMidterm $10\\%$\nFinal $40\\%$\n\n教材：\n\n$\\mathrm{Mark\\; Allen\\; Weiss}$, Data Structure and Algorithm Analysis in C (2nd Edition)\n$\\mathrm{Thomas\\; H.\\; Cormen}$, Introduction to Algorithms (3rd Edition)\n$\\mathrm{Jon\\; Kleinberg}$, Algorithm Design\n\n课程网站：Github Page\nLec 1 : Balanced BST尽管二叉搜索树可以在一定程度上加快搜索的过程，但其仍有问题。在最差的情况下，即树的每层都只有一个节点时，搜索的复杂度达到 $O(N)$ . \n此时，对于除叶节点以外的任何一个节点，他必有一个子树为空，而另一个子树非空。直观上来看这样的树就是“不平衡”的，而假如一个树是完美二叉树或者完全二叉树，对其搜索的复杂度就可以达到或接近 $O(\\log n)$ . \n因此，一个树越“平衡”，搜索的复杂度越低，我们希望找到一种具备这种平衡性的优化的 BST . 在此之前我们先来定义何为“平衡” .\nHeight Balance$【\\mathbf{Def}】$ 树的高度平衡：空树是平衡树. 若某树 $T$ 有其左子树 $T_L$ 和右子树 $T_R$，那么树 $T$ 是高度平衡的，当且仅当\n\n$T_L$ 和 $T_R$ 都高度平衡.\n$T_L$ 和 $T_R$ 的高度差的绝对值小于等于 $1$.\n\n$【\\mathbf{Def}】$ 节点的平衡因数$n$ 为树的某个节点，$h_L$ 和 $h_R$ 分别为其左右子树的高度，节点的平衡因数$BF(n)=h_L -h_R.$ 对于高度平衡树而言，$BF(n)=-1,0$ 或 $1$. 如果某个节点 $n$ 的平衡因数大于等于 $2$ ，称这个节点失衡.\nAVL Trees$\\mathrm{Adelson}$-$\\mathrm{Velskii}$-$\\mathrm{Landis}$ 树由苏联数学家格奥尔吉·马克西莫维奇和米哈伊洛维奇·兰迪斯发明.\nAVL 树是一种自平衡树，自平衡树可以动态的调整树的结构，使树在插入、删除等操作的过程中保持其平衡性。\nAVL 树的特点在于旋转操作，这种操作可以在不破坏 BST 特性（即不改变中序遍历）的前提下，使失衡的节点恢复平衡，旋转操作分为四种，分别为左旋（RR），右旋（LL），先左旋再右旋（LR），先右旋再左旋（RL）.\n► 单旋操作\n如图展示了一种简单的失衡情况：根节点 $T$ 发生失衡，这一失衡是节点 $R$ 造成的，因此可以对节点 $R$ 进行旋转. 变成如下平衡树:\n\n单个旋转操作需要保证 BST 的性质不被破坏，如图所示的情况需要将 $R$ 旋转至 $T$ 的位置，而 $T$ 将会成为 $R$ 的左子节点，应当对 $R$ 原本的左子节点 $RL$ 进行调整，使之不破坏 BST 的性质.\n单旋操作的一个实现(以左旋为例)：Tree sRoL(Tree t) &#123;    Tree tl   = t-&gt;Left;    t-&gt;Left   = tl-&gt;Right;    tl-&gt;Right = t;    t-&gt;h      = max(t-&gt;Left-&gt;Height, t-&gt;Right-&gt;Height) + 1;    tl-&gt;h     = max(getHeight(tl-&gt;Left), t-&gt;h) + 1;    return tl; &#125;\n► 双旋操作有些情况下，对失衡节点无论单旋几次都无法解决失衡，而需要先对失衡节点的子节点先进行旋转，例如如下 BST:由于失衡是节点 $LRL$ 带来的，而先对 $L$ 进行左旋再对节点 $T$ 进行右旋，使之完全平衡双旋操作的一个实现(先左旋再右旋)：Tree dRoR(Tree t) &#123;    t-&gt;Right = sRoL(t-&gt;Right);    return sRoR(t);&#125;\nSplay Trees伸展树是一种能够自我平衡的 BST, 他能够在均摊的 $O(\\log n)$ 时间内完成插入、查找等操作。\n伸展树的一个重要特点是，当一个节点 $n$ 被访问过后，会通过一系列旋转操作将 $n$ 移动到根节点处，最近访问的节点会离根节点更近，且伸展树将会越来越平衡.\n旋转操作由以下因素决定：\n\n$n$ 是其父节点 $p$ 的左子树还是右子树\n$n$ 的父节点 $p$ 是否是根节点\n$n$ 的父节点 $p$ 是其父节点 $q$ 的左子树还是右子树\n\n针对不同的情况，伸展树的操作有以下几种：\n► Zig或Zag当 $p$ 为根节点时进行，Zig 操作直接对 $p$ 进行右旋，而Zag 操作与之相反.\n► Zig-Zig或Zag-Zag当 $p$ 不为根节点，且 $n$ 和 $p$ 均为左儿子或均为右儿子，Zig-Zig 操作先对 $q$ 进行右旋，再对 $p$ 进行右旋. Zag-Zag 操作与之相反.\n► Zig-Zag或Zag-Zig当 $p$ 不为根节点，且 $n$ 和 $p$ 有一个是左儿子，另一个是右儿子的时候，Zig-Zag 操作先对 $p$ 进行左旋，再对 $q$ 进行右旋. Zag-Zig 操作与之相反.\n\n伸展树的操作基于树的旋转操作，因此三类操作都保证树的先序遍历不改变做题时可以利用这一特征，记住操作前后树的形状和 $n$, $p$, $q$ 三个节点的顺序即可\n\nAmortized Analysis对于某种数据结构，如果他的某几个特定操作速度较慢，但大多数操作速度较快，我们可以通过使用摊还分析计算多个连续的操作的平均时间复杂度. \n记最差时间为 $T_{worst}$ , 均摊时间为 $T_{amortized}$ , 平均时间复杂度为 $T_{average}$ , 那么有：\nT_{worst}\\ge T_{amortized}\\ge T_{average}上一节提到伸展树可以在均摊的 $O(\\log n)$ 时间内完成插入、查找等操作。因此任意 $m$ 个连续的操作最多使用 $O(m\\log n)$ 时间.\n以下展示一个简单的例子：对于一个栈，定义一种新的操作 multipop(s, k), 他可以连续的从栈 s 中出栈 k 个元素. 假设现在有 n 个由 push, pop, multipop 组成的操作序列.\n由于 multipop 的最差时间复杂度为 $O(n)$， 那么这些操作的最差时间复杂度为 $O(n^2)$，事实上，这一结论非常正确，但他并不是一个确界，因为参数恰为 n 的 multipop 不可能被执行 n 次. 因此需要通过摊还分析得出更准确的最差时间复杂度，也即均摊时间复杂度\n摊还分析的三种方法：聚合分析、核算法、势法\n► 聚合分析如果一系列的 $n$ 个操作总共的最差时间为 $T(n)$ . 那么平均每个操作的摊还消耗即为 $T(n)/n$ . \n上面的例子中，pop 操作的次数至多与 push 次数相等，因此 n 个由 push, pop, multipop 组成的操作序列的最差时间复杂度为 $O(n)$, 均摊下来的每个操作复杂度即为 $O(1)$.\n► 核算法当一个操作的摊还消耗 $\\hat{c_i}$ 超过了他的实际消耗 $c_i$ ，我们可以将这一差异“存”到一个“账户”中. 这一“账户”可以为之后实际消耗大于摊还消耗的操作“支付”差值.令 $D_i$ 为第 $i$ 次操作后的数据结构，$c_i$ 为第 $i$ 次操作的实际代价，$\\hat{c_i}$ 为第 $i$ 次操作的摊还代价.\n\n对于任意 $n$ 个连续操作，我们有:\n\\sum_{i=1}^n\\hat{c_i}\\ge\\sum_{i=1}^nc_i，T_{amortized}=\\frac1{n}\\sum_i^n\\hat{c_i}\n上面的例子中，三种操作的实际消耗分别是\n\npush - $1$\npop - $1$\nmultipop - $\\min\\{s,k\\}$\n\n我们可以为这三种操作分别定价，由于 push 操作会带来一个潜在的 pop 或 multipop 操作，因此可以如下定价\n\npush - $2$\npop - $0$\nmultipop - $0$\n\n在 push 操作时，除了为该操作自己支付 $1$ 的消耗以外，还要为潜在的 pop 操作往账户中预存 1 的消耗. 在 pop 时直接从账户中取出即可. 只要账户余额大于等于 $0$, 这就意味着实际消耗的上界为摊还消耗，即 $O(n)$. 每个操作的平均摊还代价为 $O(1)$\n► 势法考虑某初始数据结构 $D_0$ 上的一系列操作 $Op_1,Op_2,\\dots ,Op_n$ 这些操作引起数据结构的改变：\nD_0\\stackrel{Op_1}{\\longrightarrow}D_1\\stackrel{Op_2}{\\longrightarrow}D_2\\stackrel{Op_3}{\\longrightarrow}D_3\\stackrel{Op_4}{\\longrightarrow} \\dots\\stackrel{Op_n}{\\longrightarrow}D_n.在势法中，我们记录某一步账户中预存的消耗为 $\\Phi(D_i)$ （势能）. 由于 $\\hat{c_i}-c_i$ 为第 $i$ 步中账户余额的改变量，即 $\\Phi(D_i)-\\Phi(D_{i-1})$, 移项可得： \\hat{c_i}=c_i+\\Phi(D_i)-\\Phi(D_{i-1}).\n为了开始势法的分析，我们需要为数据结构定义一个势函数：$\\Phi:D\\rightarrow \\mathbf{R}_0^+$，这一函数满足：\n\nTypically, $\\Phi(D_0)=0$.\n$\\Phi(D_i)\\ge\\Phi(D_0)$, for all $i$.\n\n\nExample : 势法分析 Splay 树均摊复杂度：定义某结点 $X$ 的势函数为 $\\sigma(X)=\\log size(X)$ (对平衡树而言， $\\log size(X)$ 接近树的高度)\n那么整棵树的势函数便可定义为 \\Phi(T)=\\sum_{X\\in T}\\sigma(X). \n满足势函数的条件. 接下来分析各种旋转操作下的势函数变化量：\n\nzig / zag 旋转这种情况下，只有节点 $n$ 和 $p$ 的势发生了变化，且 $n$ 和 $p$ 各自先后作为根节点时，其势能相同。记旋转后的节点为 $n^\\prime$ 和 $p^\\prime$. 则势能变化为：\\Delta\\Phi=\\sigma(n^\\prime)+\\sigma(p^\\prime)-\\sigma(n)-\\sigma(p).\\\\=\\sigma(p^\\prime)-\\sigma(n)\\le\\sigma(n^\\prime)-\\sigma(n)\nzig-zig / zag-zag 旋转类似的分析\\Delta\\Phi=\\sigma(n^\\prime)+\\sigma(p^\\prime)+\\sigma(q^\\prime)-\\sigma(n)-\\sigma(p)-\\sigma(q)\\\\=\\sigma(p^\\prime)+\\sigma(q^\\prime)-\\sigma(n)-\\sigma(p)由于：$size(n)+size(q)=size(n)-1&lt;size(n).$可得：\\Delta\\Phi"},{"title":"🖊️ 计算机学院 计算机组成 （Computer Organization）","url":"/2024/02/28/ca/","content":"\n\\mathrm{Alan\\;Mathison\\;Turing}1912-1954Basic info课程名：计算机组成 （Computer Organization）\n主讲教师： $\\mathbf{A.P.}$ $\\mathrm{De}$ $\\mathrm{Ma}$\nE-Mail：$\\mathrm{made@zju.edu.cn}$\n分数占比：\n\nAssignment $10\\%$\nPresence $10\\%$\nQuiz $10\\%$\nLab $30\\%$\nLab 0 ~ 3 基本实验 $30\\%$\nLab 4 单周期 CPU $30\\%$\nLab 5 流水线 CPU $30\\%$\nLab 6 Data Cache $10\\%$\n\n\nFinal $40\\%$\n\n教材：\n\n$\\mathrm{David\\; A.\\; Patterson}$, Computer Organization and Design RISC-V Edition: The Hardware Software Interface\n\nFPGA 平台：Artix 7, XC7A100T, CSG324, -1. \nLec 1 : PreludeTechnologies for building processors and memory\\mathrm{Cost\\; per\\; die=\\frac{Cost\\; per\\; wafer}{Dies\\; per\\; wafer\\times Yield}.}\\mathrm{Dies\\; per\\; wafer\\approx \\frac{Wafer\\; area}{Die\\; area}.}\\mathrm{Yield=\\frac1{(1+(Defects\\; per\\; area\\times Die\\; area/2))^2}.}Yield is the proportion of working dies per wafer. \nLec 2 : Arithmetic for Computer#midterm：单周期处理器。\n"},{"title":"🖊️ 计算机学院 数据库系统 （Database System）","url":"/2024/02/29/db/","content":"Basic info课程名：数据库系统 （Database System）\n主讲教师： $\\mathbf{Prof.}$ $Gang$ $Chen$\nE-Mail：$cg@zju.edu.cn$\n分数占比：\n\nAssignment $10\\%$\nQuiz $10\\%$\nLab $30\\%$\nFinal $50\\%$ （Cheat sheet allowed）\n\n教材：\n\n$Abraham Silberschatz$, Database System Concepts (7th Edition).\n\nLec 1 : Introduction\nAbstraction of a database system：\nPhysical Level: Describes how a record is stored\nLogical Level: Describes data stored in database, and the relationships among the data on upper level.\nView Level: Application programs hide details of data types.\n\n\n► Schema $\\leftrightarrow$ Type：The structure of the database on different level.\n\nPhysical Schema: database structure design at the physical level.\nLogical Schema: database structure design at the logical level.\nSubschema: schema at view level.\n\n► Instance $\\leftrightarrow$ Variable: The actual content of the database at a particular point in time.\n\nIndependence: Ability to modify a schema definition at one level without affecting a schema definition at a higher level.\n\nPhysical data independence: The ability to modify the physical schema without changing the logical schema.\nApplications depend on the logical schema.\nApplications are insulated (绝缘的) from how data is structured and stored.\nOne of the most important benefits of using a DBMS.\n\n\nLogical data independence: Protect application programs from changes in logical structure of data.\nHard to achieve as the application programs are heavily dependent on the logical structure of data.\n\n\n\nDatabase Languages: \n\nData Definition Language: Specification notation for defining the database schema.\nSpecifies  a database schema as a set of definitions of relational schema\nAlso specifies storage structure, access methods, and consistency constraints.\nDDL statements are compiled, resulting in a set of tables stored in a special file called data dictionary.\n\n\nData Manipulation Language: Language for accessing and manipulating the data organized by appropriate data model.\n\nData Control Language\n\n\nLec 2 : Relational ModelA Relation is a table with rows and columns.\nA relational database is a collection  of one or more relations, which are based on the relational model\nRelationsBasic Definition of a relation:Formally, given sets $D_1,D_2,\\dots,D_n (D_i=a_{ij}|_{j=1\\dots k})$, a relation $r$ is a subset of $D_1\\times D_2\\times \\dots \\times D_n$.\nAttribute Types：\nEach attribute of a relation has a name. \nThe set of allowed values for each attribute is called the domain of the attribute.\n$1^{st} NF$: Attribute values are required to be atomic (indivisible) \nThe special value null is a member of every domain.\n\nA relation is concerned with two concepts: relation schema and relation instance.\n\nThe relation schema describes the structure of the relation\nThe relation instance corresponds to the snapshot of the data in the relation at a given instant in time\nAssume $A_1,A_2,\\dots,A_n$ are attributes, then \\mathbf{R}=(A_1,A_2,\\dots,A_n)  \nis a relation schema$r(\\mathbf{R})$ is a relation on the relation schema $\\mathbf{R}$\n\n\n\nProperties of a relation:\nThe order of tuples is irrelevant.\nNo duplicated tuple in a relation.\nAttribute values are atomic.\n\nDatabase：\nA database consists of multiple relations.\n\n\nKey$K\\subseteq \\mathbf{R}$. (An attribute of the relation schema)\n\nSuperkey: $K$ is a superkey of $\\mathbf{R}$ if values for $K$ are sufficient to identify a unique tuple of each possible relation $r(\\mathbf{R})$.\nCandidate Key: $K$ is a candidate key if it is minimal superkey.\nPrimary key: $K$ is a Primary key if $K$ is a candidate key and is defined by user explicitly.\nForeign key: Assume there exists relations $r$ and $s$: $r(A,B,C),s(B,D)$, we can say that attribute $B$ in relation $r$ is foreign key referencing $s$ and $r$ is a referencing relation and $s$ is a referenced relation. There are two types of constraints:\nForeign-key constraint: \nthe value of $B$ for each tuple in $r$ must also be the value of $B$ for some tuple in $s$.\n$B$ must be the primary key of $s$.\n\n\nReferential-integrity constraint:\nthe value of $B$ for each tuple in $r$ must also be the value of $B$ for some tuple in $s$.\nUsually not supported by Database Systems.\n\n\n\n\n\nTake the table above as an example, id and name are both superkey. birth year and weight is a superkey when we combine them together. \nSuperkey id or name have only one attribute, thus they are both candidate key. The user can decide which one becomes the primary key.\nIf a connection should be established between the table and another table which have id as an attribute, then id is a foreign key.\nFundamental Relational-Algebra OperationsThere are six basic operators:\nSelectdefined as $\\sigma_p(r)=\\{t|t\\in r \\land p(t)\\}$, where $p$ is a formula in propositional calculas consisting of terms connected by $\\land, \\vee, \\neg.$ e.g. \n\\mathrm{\\sigma_{customer-name='Dickson'\\ \\land\\ type='debit'}(account).}Projectdefined as $\\prod_{A_1,A_2,\\dots,A_k}(r).$ Where $A_1,A_2,\\dots,A_k$ are attribute names and $r$ is a relation name. The result is defined as the relation of $k$ columns obtained by erasing the columns that are not listed. Note that duplicated rows must be removed from the result.  \nUniondefined as $r\\cap s=\\{t|t\\in r\\vee t\\in s\\}.$ where $r$ and $s$ must have the same number of attributes, and the attribute domains must be compatible.  \nSet Differencedefined as $r-s=\\{t|t\\in r \\land t \\notin s\\}.$ where $r$ and $s$ must have the same number of attributes, and the attribute domains must be compatible.\nCartesian Productdefined as $r\\times s=\\{ \\{t ,q\\}|t\\in r \\land q\\in s\\}$. Assume that attributes of $r(\\mathbf{R})$ and $s(\\mathbf{S})$ are disjoint. If attributes of $r(\\mathbf{R})$ and $s(\\mathbf{S})$ are not disjoint, then renaming for attributes must be used.\nRenamedefined as $\\rho_x(E)$, essential when self-compare occurs, e.g. $\\mathrm{\\max(r)}$.\nAdvancedNatural Join OperationNotation: $r\\bowtie s$Example:$\\mathrm{R=(A,B,C,D), S=(B,D,E)}$\n\\mathrm{r\\bowtie s=\\prod_{r.A,r.B,r.C,r.D,s.E}(\\sigma_{r.B=s.B\\land r.D=s.D}(r\\times s))}Theta join OperationNotation: $r\\bowtie_\\theta s$where $\\theta$ is the predicate on attributes in the schema. note that \\mathrm{r\\bowtie_\\theta s=\\sigma_\\theta(r\\times s)}\nDivision OperationNotation: $r\\div s$The backward operation of Cartesian Product.\n\\mathrm{  r\\div s=\\prod_{R-S}(r)-\\prod_{R-S}((\\prod_{R-S}(r\\times s)-\\prod_{R-S,S}(r)) ) }.Assignment OperationNotation: $r\\leftarrow s$\nLec 3 : SQLSQL /ˈsēkw(ə)l/ (Structured Query Language, 结构化查询语言)SQL includes these parts:\n\nData-Definition Language\nCREATE TABLE;\nDROP TABLE;\n\n\nData-Manipulation Language\nSELECT * FROM TABLE;\nINSERT\n\n\nData-Control Language\nGRANT\n\n\n\nData-Definition LanguageWhat can DDL do?\nCreate, drop or alter table and Define the schema for relationsfor example,CREATE TABLE dick            (dick_owner  char(20) not null,             dick_length numeric(2, 2),             dick_radius numeric(2, 2),             primary key (dick_owner));creates a new table names dick , and contains three attribute dick_owner, dick_length and dick_radius. We set dick_owner the primary key as no dick can be owned by two.DROP TABLE dick;this command deletes all information about the dropped relation from the database.One should be careful and responsible to use the DROP command.ALTER TABLE dick ADD dick_angle numeric(2, 2);ALTER TABLE dick DROP dick_angle; //not supported by many DBMSALTER TABLE dick MODIFY (dick_owner varchar(20));this command is used to add, drop or edit attributes to an existing relation\n\nNote:“-“ character is invalid in names.SQL names are case-insensitive.\nDefine the domain of values associated with each attributeThere are several types of domain in SQL\n\nchar(n) : Fixed length character string, the length must be n.\nvarchar(n) : Variable length character string, the maximum length is n.\nint : Integer (depend on the machine)\nsmallint : Subset of Integer type (depend on the machine)\nnumeric(p, d) : Fixed point number, precision is p digits, d digits to the right of decimal point.\nreal, double precision : Floating point and double-precision floating point numbers.\nfloat(n) : Floating point number, precision at least n digits.\nNULL : nothing.\ndate : Contain year, month and day.\ntime : Time of a day. Contain hour, minute and second.\ntimestamp : date and time.\n\n\nFunctions can be used to handle the conversion of different types. such as Abs(), exp()…\nDefine the integrity constraints.Integrity Constraints are the protocols that a table’s data columns must follow. Some integrity constraints are shown below:\n\nNot null\nPrimary key (A, B, ..., Z), ( for SQL_92, this constraint ensures Not null )\nCheck (P), where P is a predicate, value of this attribute of each tuple must satisfy P.\n\nOther\nDefine the physical storage structure of each relations on disk\nDefine the indices to be maintained for each relations\nDefine the view on relations\n\nBasic Structure of commandselect clauseA typical SQL query can have the form:SELECT (DISTINCT) A, B, ... FROM   r, s, ...WHERE  PGROUP BY C, D, ... HAVING QORDER BY E, F, ...\nwhere A and B are attributes; r and s are relations; P is a predicate. \nThis query is equivalent to the relational algebra expression:\n\\prod_{A, B,\\dots}(\\sigma_P(r\\times s\\times \\dots)).the result of query is also a relation.\nDistinct: In the result of query, duplicates is allowed by default, if we want it to be eliminated, key word distinct can be use:SELECT distinct dick_lengthFROM dick\n\nNote that distinct means every tuple is distinct in the result relation, but not every value of one attribute is distinctive.\n\nAsterisk (*): An asterisk in the select clause denotes all attributes.SELECT * FROM dickThe asterisk can also be used in arithmetic expressions, such asSELECT dick_owner, dick_length * 10FROM dick;where clause: The where clause specifies conditions that the result must satisfy.SELECT dick_ownerFROM dickWHERE dick_length &gt; 30;the SQL query returns all the names of whom have a dick longer than 30. It’s equivalent to the relational algebra expression:\n\\prod_{\\mathrm{dick\\_owner}}(\\sigma_{\\mathrm{dick\\_length>30}}(\\mathrm{dick})).The predicate, P can be a combination of several predicates connected with logical connectives including AND, OR and NOT.\nfrom clause: the FROM clause lists the relations involved in the query. If more than one relation is specified in the clause, than select from the Cartesian product relation of all relations.SELECT dick.dick_owner, dick_length, dick_used_countFROM dick, dick_usage_recordWHERE dick.dick_owner = dick_usage_record.dick_owner AND      dick_used_count &gt; 114514 AND      dick_length     &gt; 30The query selects the name of those who have a dick longer than 30 and used for more than 114,514 times. Note that dick.dick_owner is necessary because there are two dick_owner attribute in total.rename(as): The SQL allows renaming relations and attributes using the as clause.SELECT dick.dick_owner as excellent_dick_owner,        dick_length, dick_used_countFROM dick, dick_usage_recordWHERE dick.dick_owner = dick_usage_record.dick_owner AND      dick_used_count &gt; 114514 AND      dick_length     &gt; 30tuple variables: renaming the relation temporarily in the query.for simplification:SELECT r.dick_owner, dick_length, dick_used_countFROM dick as r, dick_usage_record as sWHERE r.dick_owner    = s.dick_owner AND      dick_used_count &gt; 114514 AND      dick_length     &gt; 30for self-comparing, the following query selects all the name of those who’s dick is longer than cartman:SELECT DISTINCT r.dick_owner, r.dick_lengthFROM dick as r, dick as sWHERE r.dick_length &gt; s.dick_length AND      s.dick_owner  = &quot;cartman&quot;;\nstring operationsSQL includes a string-matching operator for comparisons on character strings\n\n% matches any substring\n_ matches any character\n|| Concat strings\nlower()\nupper()\n\nLIKE clause can be used to form a predicatee.g. find all dick owner who’s name ends with ‘son’WHERE dick_owner LIKE &#x27;%son&#x27;e.g.SELECT &#x27;dick length of him is &#x27; || dick_lengthFROM dickWHERE dick_owner LIKE &#x27;%son&#x27;\nordering of display of tuplesThough tuples in the databse is inordered, but we can define how it will display by using ORDER BY clause.SELECT dick_ownerFROM dickWHERE dick_length &gt; 30ORDER BY dick_length DESC\nSet OperationThere are there basic type of Set operations:\n\nUNION : $A\\cap B$.\nINTERSECT : $A\\cup B$.\nEXCEPT : $A - B$.\n\nThe three operations eliminates duplicates automatically, if we want every tuple, use ALL clause.e.g.(SELECT dick_owner FROM dick WHERE  dick_length &gt; 30)UNION(SELECT dick_owner FROM dick_usage_record WHERE  dick_used_count &gt; 114514)\nAggregate FunctionsThere are functions operate on the multiset values of a relation’s column, and returns a value.\n\navg(col) : average value\nmin(col) : minimum value\nsum(col) : sum of values\ncount(col) : number of values\n\ne.g. Find the average dick length of those who’s name ends with ‘son’SELECT avg(dick_length) avg_dick_lengthFROM dickWHERE dick_owner LIKE &#x27;%son&#x27;;GROUP BY: if an attribute in the SELECT clause isn’t in the aggregate function, it shall be put into GROUP BY list.SELECT dick_owner, avg(dick_length) avg_dick_lengthFROM dickWHERE dick_owner LIKE &#x27;%son&#x27;GROUP BY dick_owner;HAVING: Make predicates on the result of aggregate function.HAVING avg(dick_length) &gt; 10\nExecution of SELECTThe execution order of SELECT clause is FROM$\\rightarrow$WHERE$\\rightarrow$GROUP(functions)$\\rightarrow$HAVING$\\rightarrow$SELECT$\\rightarrow$DISTINCT$\\rightarrow$ORDER BY\n\nNote that predicates in the HAVING clause are applied after GROUP.Aggregate functions can’t be used in WHERE clause directly.\n\nNULL valuesNULL is a special marker used in SQL, first introduced by $\\mathrm{E.F.Codd.}$. It means ‘missing information’ or ‘unknown’\n\nThe result of any arithmetic expression involving NULL is NULL.\nAny comparison with NULL returns UNKNOWN.\nNULL = NULL\n\n\n\nThree valued logic : $\\mathrm{\\{true,false,UNKNOWN\\}}$ \n\nUNKNOWN or TRUE = TRUE\nUNKNOWN or FALSE = UNKNOWN\nUNKNOWN or UNKNOWN = UNKNOWN\nUNKNOWN and TRUE = UNKNOWN\nUNKNOWN and FALSE = FALSE\nUNKNOWN and UNKNOWN = UNKNOWN\nnot UNKNOWN = UNKNOWN\n\nUNKNOWN is treated as FALSE in WHERE clauses.\nP IS UNKNOWN predicate evaluates to true if predicate P equals to UNKNOWN\nIS NULL and IS NOT NULL predicates:e.g. find all valid tuples:SELECT dick_ownerFROM dickWHERE dick_length IS NOT NULL;\nNULL will be ignored in aggregate functions except COUNT().\nNested SubqueriesA subquery is a SELECT_FROM_WHERE expression that is nested within another query. A common usage of subqueries is to perform tests for set membership and set comparisons.\ne.g. Find all person who is both rich and stupid.SELECT distinct namesFROM richieWHERE names IN (SELECT names                 FROM douchebag)e.g. Find all person who is both rich and NOT stupid.SELECT distinct namesFROM richieWHERE names NOT IN (SELECT names                     FROM douchebag)e.g. Find the owner of the biggest dick for every citySELECT dick_owner B, dick_lengthFROM dick AWHERE dick_length &gt;= (SELECT max(dick_length)                      FROM dick B                      WHERE A.city = B.city)ORDER BY dick_length\nSome and all clause$C[comp]$ SOME $r\\leftrightarrow \\exist t\\in r, C[comp]t$ holds, where $[comp]$ could be $&lt;,&gt;,\\le,\\ge,=,\\neq.$\nFor example $6&lt;$ SOME $\\{2,4,5,7\\}=$ TRUE.\n\n$(=$ SOME $)\\equiv$ IN.\n\n$C[comp]$ ALL $r\\leftrightarrow \\forall t\\in r, C[comp]t$ holds, where $[comp]$ could be $&lt;,&gt;,\\le,\\ge,=,\\neq.$\nFor example $6&lt;$ ALL $\\{5,7,9,10\\}=$ FALSE.\n\n$(\\neq$ ALL $)\\equiv$ NOT IN.\n\nTest for empty relationsEXISTS construct returns the value TRUE if the argument subquery is non-empty.\nEXISTS $r\\leftrightarrow r\\neq \\phi.$\nTest for absence of Duplicate TuplesUNIQUE construct tests whether a subquery has any duplicates in its result.e.g. Find all person who have only one childSELECT namesFROM child as TWHERE UNIQUE (SELECT names              FROM child AS P              WHERE T.names = P.names)\nViewsViews provide a mechanism to hide certain data from the view of certain users.\nTo create a view we use:CREATE VIEW &lt;name_v&gt; AS    SELECT ... FROM ... WHERE ...To drop a view we use:DROP VIEW &lt;name_v&gt;Benefits of using a view\n\nEasy to use.\nSecurity.\nSupports logical independent.\n\nDerived RelationsWITH clause allows views to be defined locally for a query rather than globally.\n"},{"title":"🇭🇰 香港游记","url":"/2024/03/03/hktrip/","content":""},{"title":"🖊️ 计算机学院 面向对象程序设计 （Object-Oriented Programming）","url":"/2024/02/29/oop/","content":"Basic info课程名：面向对象程序设计 （Object-Oriented Programming）\n主讲教师： $\\mathbf{Prof.}$ $Wei$-$Wei$ $Xu$\nE-mail：$xww@cad.zju.edu.cn$\n分数占比：\n\nLab Project 50%\nWeek 2, 4, 6, 8, 10, 12, 14, 16.\nDeadline: Midnight of Saturday\n\n\nFinal 50%\n\n教材：\n\n$Bruce Eckel$, Thinking in C++ (Edition 2)\n$Daniel B. Lippman$, C++ Primer (Edition 5)\n\nGithub仓库：Github\nLec 2 : Memory"},{"title":"🖊️ 计算机学院 数值分析 （Numerical Analysis）","url":"/2023/12/10/na/","content":"Basic info课程名：数值分析 （Numerical Analysis）\n主讲教师： $\\mathbf{Prof.}$ $Wei$-$Wei$ $Xu$\nE-mail：$xww@cad.zju.edu.cn$\n分数占比：\n\n作业 (交了即接近满分) 5%\n小测 (交了即满分) 4%\nResearch Topic (做了即满分) 15%\nLab Project 36%\nFinal (开卷) 40%\n\n教材：\n\n$Richard L. Burden$, Numerical Analysis (7th Edition)\n课程 Slide\n\n给分：$97/5.0$\n推荐程度：★★★★★\nChap 2 : 一元方程的求解Sec 1 二分法二分法：$f$ 是定义在区间 $[a,b]$ 上的连续函数，$f(a)$ 与 $f(b)$ 异号，则存在 $p\\in[a,b],f(p)=0$ 算法的核心是将搜索区间反复减半，每一步找出含有 $p$ 的那一半fa=f(a);while(i&lt;=n)&#123;    p = (a+b)/2;    fp = f(p);    if(fp==0||(b-a)/2&lt;TOL)    &#123;        output(p);    &#125;    i++;    if(fa*fp&gt;0)        a=p;fa=fp;    else        b=p;&#125;\n虽然二分法在概念上很容易，但他有重大缺陷：\n\n收敛较慢.\n好的中间近似解可能被丢弃.\n\n但是，二分法总收敛于一个解.\n二分法产生出逼近 $f$ 的零点 $p$ 的序列 $p_n$ 有：|p_n-p|\\le\\frac{b-a}{2^n},n\\ge 1.\n\nSec 2 不动点迭代不动点：如果有 $g(p)=p$, 那么 $p$ 是 $g$ 的一个不动点.\n求函数 $g$ 的不动点问题等价于求 $f(x)=x-g(x)$ 的零点的问题.\n\n如果 $g\\in C[a,b],g(x)\\in[a,b]$ 对所有 $x\\in[a,b]$ 成立, 那么 $g$ 在 $[a,b]$ 有一个不动点.\n条件1前提下，若 $g^\\prime$ 存在, 且存在 $0&lt;k&lt;1$ 使得 $|g^\\prime(x)|\\le k$ 对于 $x\\in[a,b]$ 成立，那么该不动点是唯一的.\n条件1, 2前提下，对 $[a,b]$ 内任意点 $p_0$ 由 $p_n=g(p_{n-1})$ 确定的序列收敛于唯一不动点 $p$.\n条件1, 2前提下，用 $p_n$ 逼近 $p$ 的误差界为：$|p_n-p|\\le k^n\\max{ \\{p_0-a,b-p_0\\}}.$ 且 $|p_n-p|\\le \\frac{k^n}{1-k}|p_1-p_0|.$\n\n不动点迭代的代码实现是显然的.\n\nSec 3 $Newton$ 迭代法$Newton$ 法：假设 $f\\in C^2[a,b]$ 利用 $Taylor$ 展开式可以得到 $Newton$ 迭代法为：p_n=p_{n-1}-\\frac{f(p_{n-1})}{f^\\prime(p_{n-1})}.\n假设 $f\\in C^2[a,b]$  如果 $p\\in[a,b]$ 满足 $f(p)=0, f^\\prime(p)\\neq0$, 那么存在 $\\xi&gt;0$,使得任意初始近似 $p_0\\in[p-\\xi,p+\\xi]$, $Newton$ 迭代法收敛.\n正割法：利用 $f^\\prime(p_{n-1})\\approx\\frac{f(p_{n-1})-f(p_{n-2})}{p_{n-1}-p_{n-2}}$. 优化 $Newton$ 法求导数的困难，有\np_n=p_{n-1}-\\frac{f(p_{n-1})(p_{n-1}-p_{n-2})}{f(p_{n-1})-f(p_{n-2})}.正割法比函数式迭代快得多，但是比 $Newton$ 迭代慢一点，由于 $Newton$ 法和正割法需要一个好的近似值，而这个近似值可以由二分法提供。\n试位法：以与正割法相同的方式产生近似解，但是他增加了一个检验以保证在相邻的迭代间包含根。\n以下是试位法的实现：int i = 2;q0=f(p0);q1=f(p1);while(i&lt;n)&#123;    p = p1 - q1*(p1-p0)/(q1-q0);   //Secant method.    if(p-p1&lt;TOL)        return;    i++;    q=f(p);    if(q*q1&lt;0)    &#123;        p0=p1;        q0=q1;    &#125;    p1=p;    q1=q;&#125;\n\nSec 4 迭代法的误差界分析假设 $p_n$ 是一个线性收敛序列，其极限为 $p$,如果存在 $\\lambda$ 和 $\\alpha$ 使得 \\lim_{n\\to\\infty}\\frac{|p_{n+1}-p|}{|p_n-p|^2}=\\lambda.则称 $p_n$ 以阶 $\\alpha$ 收敛于 $p$，渐进误差常数为 $\\lambda$.\n\n$\\alpha=1$ 为线性收敛，不动点迭代是线性收敛\n$\\alpha=2$ 为二次收敛\n\n若 $p$ 是方程 $x=g(x)$ 的解。$g^{\\prime\\prime}$ 以 $M$ 为界，若 $g^\\prime(p)=0$, 那么存在 $\\delta$, 使得初值为 $p_0\\in[p-\\delta,p+\\delta]$ 的序列至少二次收敛于 $p$.且，当 $n$ 足够大,|p_{n+1}-p|\\sum_{j=1,j\\neq i}^n|a_{ij}|.对每一个 $i=1,2…n$ 成立时。  \n严格对角占优阵是满秩的。并且，对于此严格对角占优阵 $\\mathbf{A}$， $Gauss$ 消去法可以用在形如 $\\mathbf{Ax=b}$ 的任何线性方程组以得到其唯一解而不需要行交换或列交换。对于舍入误差的增长而言计算是稳定的。  \n正定阵：一个阵 $\\mathbf{A}$ 是正定的若\n\n$\\mathbf{A^T=A},$\n$\\mathbf{x^TAx}&gt;0,$ 对于任意向量 $\\mathbf{x}.$  \n\n且  $\\mathbf{A}$ 是正定的 $\\leftrightarrow$ \n\n$\\mathbf{A}$ 满秩.\n$\\mathbf{A}$ 的主对角线元素 $a_{ii}&gt;0.$\n$\\max_{1\\le k,j\\le n}|a_{kj}|\\le \\max_{1\\le i \\le n}|a_{ii}|.$\n$(a_{ij})^2&lt;a_{ii}a_{jj},$ 对每个 $i\\neq j.$\n没有行交换的 $Gauss$ 消去法可以在所有主元为正的线性方程组 $\\mathbf{Ax=b}$ 上进行，计算相对于舍入误差的增长稳定.  \n$\\mathbf{A}$ 可分解为形式 $\\mathbf{LDL}^T$, 其中， $\\mathbf{L}$ 是主对角线元素全为 1 的下三角矩阵，$\\mathbf{D}$ 是主对角线值为正的对角矩阵.\n$\\mathbf{A}$ 可分解为形式 $\\mathbf{LL}^T$, 其中， $\\mathbf{L}$ 是具有非零主对角线元素的下三角矩阵.  \n\n推论：若 $\\mathbf{A}$ 在 $Gauss$ 消去法的过程中无需行交换，那么 $\\mathbf{A}$ 可以进行 $\\mathbf{LDL}^T$ 分解。\n $\\mathbf{LDL}^T$ 分解： for(int i = 1; i &lt;= n; i++)&#123;   for(int j = 1; j &lt;= i + 1; j++)       v[j] = L[i][j]*D[j];   sum_lv = ...;   D[i] = a[i][i] - sum_lv   for(int j = i + 1; j &lt;= n; j++)       sum_lv2 = ...;       L[j][i] = (a[j][i] - sum_lv2) / d[i];&#125;\n其中 sum_lv = $\\sum_{j=1}^{i-1}l_{ij}v_j,$ sum_lv2 = $\\sum_{k=1}^{i-1}l_{jk}v_k.$  \n$\\mathbf{LDL}^T$ 分解的复杂度：\n\n$\\mathbf{LDL}^T$ 分解算法需要 \\sum_{i=1}^{n}2(i-1)+i(n-i)=\\frac16n^3+n^2-\\frac76n 次乘法/除法；\\sum_{i=1}^{n}(i-1)(n-i+1)=\\frac16n^3-\\frac16n 次加法/减法.    \n\n$\\mathbf{LL}^T$ 分解 ( $Choleski$ 算法 )：L[1][1] = sqrt(a[1][1]);for(int j = 2; j &lt;= n; j++)    L[j][1] = a[j][1] / l[1][1];for(int i = 2; j &lt;= n - 1; j++)&#123;    L[i][i] = sqrt(a[i][i] - sum_l);    for(int j = i + 1; j &lt;= n; j++)        L[j][i] = (a[j][i] - sum_l2)/L[i][i];&#125;L[n][n] = sqrt(a[n][n] - sum_l3);\n其中 sum_l = $\\sum_{k=1}^{i-1}l_{ik}^2,$ sum_l2 = $\\sum_{k=1}^{i-1}l_{jk}l_{ik}.$ sum_l3 = $\\sum_{k=1}^{n-1}l_{nk}^2.$   \n$\\mathbf{LL}^T$ 分解的复杂度：\n\n$\\mathbf{LL}^T$ 分解算法需要 \\sum_{i=1}^{n}(i-1)+i(n-i)=\\frac16n^3+\\frac12n^2-\\frac23n 次乘法/除法；\\sum_{i=1}^{n}(i-1)(n-i+1)=\\frac16n^3-\\frac16n 次加法/减法.但是，$\\mathbf{LL}^T$ 还需要 $n$ 次平方根运算。\n\n带状矩阵：$\\mathbf{A}$ 是一个带状矩阵，如果存在整数 $p$ 和 $q$ ($1&lt; p,q&lt;n$) 使得当 $i+p\\le j$ 或 $j+q\\le i$ 时，有 $a_{ij}=0.$ $\\mathbf{A}$ 的带宽定义为 $\\omega=p+q-1.$  \n三对角矩阵：当 $p=q=2, \\omega=3$ 时的带状矩阵被称作三对角矩阵.三对角矩阵的性质可以使他的分解过程大大简化，可以对其进行 $Crout$ 分解。\n$Crout$ 分解：三对角矩阵可以通过 $Crout$ 分解得到一个下三角矩阵 $\\mathbf{L}$, 和一个主对角线元素为 1 的上三角矩阵 $\\mathbf{U}$.\n\\begin{bmatrix}\n    a_1&c_1&0&\\dots&0\\\\\n    b_2&a_2&c_2&\\dots&0\\\\\n    0&b_3&a_3&\\dots&0\\\\\n    \\dots&\\dots&\\dots&\\dots&\\dots\\\\\n    0&0&0&\\dots&a_n\n\\end{bmatrix}=\\begin{bmatrix}\n    l_1&0&0&\\dots&0\\\\\n    m_2&l_2&0&\\dots&0\\\\\n    0&m_3&l_3&\\dots&0\\\\\n    \\dots&\\dots&\\dots&\\dots&\\dots\\\\\n    0&0&0&\\dots&l_n\n\\end{bmatrix}\\begin{bmatrix}\n    1&u_1&0&\\dots&0\\\\\n    0&1&u_2&\\dots&0\\\\\n    0&0&1&\\dots&0\\\\\n    \\dots&\\dots&\\dots&\\dots&\\dots\\\\\n    0&0&0&\\dots&1\n\\end{bmatrix}其中，\\begin{array}\nrm_i=b_i;\\\\\nl_i=a_i-m_iu_{i-1};\\\\\nu_i=c_i/l_i;\n\\end{array}\n以下代码可用于产生矩阵 $\\mathbf{A}=(a_{ij})_{n\\times n}$ 的 $Crout$ 分解并解出 $x$L[1][1] = a[1][1];U[1][2] = a[1][2]/L[1][1];z[1] = a[1][n+1]/L[1][1];for(int i = 2; i &lt;= n-1; i++)&#123;    L[i][i-1] = a[i][i-1];    L[i][i] = a[i][i]-L[i][i-1] * U[i-1][i];    U[i][i+1] = a[i][i+1] / L[i][i];    Z[i] = (a[i][n+1] - L[i][i-1] * z[i-1]) / L[i][i];&#125;L[n][n-1] = a[n][n-1];L[n][n] = a[n][n] - L[n][n-1] * U[n-1][n];z[n] = (a[n][n+1] - L[n][n-1]*z[n-1])/L[n][n];x[n] = z[n];for(int i = n-1; i &gt;= 1; i--)&#123;    x[i] = z[i] - U[i][i+1]*x[i+1];&#125;\n$Crout$ 分解的复杂度：\n\n$Crout$ 分解算法需要 4+n+\\sum_{i=2}^{n-1}4=5n-4 次乘法/除法；1+n+\\sum_{i=2}^{n-1}2=3n-3 次加法/减法. \n\n\nChap7 : 矩阵代数中的迭代方法Sec 1 向量和矩阵的范数向量范数：$\\mathbf{R}^n$ 上的向量范数是一个从 $\\mathbf{R}^n\\rightarrow\\mathbf{R}$ 的函数 $f(\\mathbf{x}) =||\\mathbf{x}||$, 如果他满足以下的性质\n\n$||\\mathbf{x}||\\ge0$ , 对任意 $\\mathbf{x}\\in\\mathbf{R}^n.$\n$||\\mathbf{x}|| =0\\leftrightarrow\\mathbf{x=0}.$\n$||\\mathbf{\\alpha x}|| =|\\alpha|\\cdot||\\mathbf{x}||$ , 对任意 $\\mathbf{x}\\in\\mathbf{R}^n.$\n$||\\mathbf{x+y}||\\le ||\\mathbf{x}||+||\\mathbf{y}||$ , 对任意 $\\mathbf{x},\\mathbf{y}\\in\\mathbf{R}^n.$  \n\n$l_2$ 范数：向量 $\\mathbf{x}$ 的 $l_2$ 范数定义为 ||\\mathbf{x}||_2=\\sqrt{\\sum_{i=1}^nx_i^2}.  \n事实上，向量的 $l_2$ 范数就是该向量在欧氏空间中到原点的距离，因此也被称作 $Euclidean$ 范数.\n$l_\\infty$ 范数（无穷范数）：向量 $\\mathbf{x}$ 的 $l_\\infty$ 范数定义为 ||\\mathbf{x}||_\\infty=\\max_{1\\le i\\le n}{|x_i|}.  \n向量的范数给出了任意向量和 $\\mathbf{0}$ 向量之间距离的度量，因此两个向量间的距离可以由向量之差的范数定义。\n矩阵范数：$n\\times n$ 矩阵集合上定义的 函数 $f:\\mathbf{R}^{n\\times n}\\rightarrow\\mathbf{R}$ 是一个矩阵范数, 如果对于任意矩阵 $\\mathbf{A,B}\\in\\mathbf{R}^{n\\times n}$ 满足：\n\n$||\\mathbf{A}||\\ge0$.\n$||\\mathbf{A}|| =0\\leftrightarrow\\mathbf{A=0}.$\n$||\\mathbf{\\alpha A}|| =|\\alpha|\\cdot||\\mathbf{A}||$.\n$||\\mathbf{AB}||\\le ||\\mathbf{A}||\\cdot||\\mathbf{B}||$.\n\n自然/从属矩阵范数：假设 $||\\cdot||$ 为 $\\mathbf{R}^n$ 上的一个向量范数，那么定义矩阵的自然矩阵范数为：\n||\\mathbf{A}||=\\max_{||\\mathbf{x}||=1}||\\mathbf{Ax}||.自然范数下的矩阵范数与单位向量范数密切相关。$\\mathbf{Ax}$ 可以考虑为对 $\\mathbf{x}$ 的一个变换.\n矩阵从属无穷范数：定义 $\\mathbf{A}=(a_{ij})$ 为一个 $n\\times n$ 的矩阵，取 $||\\cdot||_\\infty$ 为 $\\mathbf{R}^n$ 上的向量 $l_\\infty$ 范数, 那么矩阵的从属无穷范数为\n||\\mathbf{A}||_\\infty=\\max_{||\\mathbf{x}||=1}||\\mathbf{Ax}||_\\infty=\\max_{1\\le i\\le n}\\sum_{j=1}^n|a_{ij}|.Sec 2 特征值与特征向量回忆线性代数知识：一个 $n\\times n$ 矩阵可以看作一个 $n$ 维空间到自己的函数。此情况下，某些非零向量 $\\mathbf{x}$ 与 $\\mathbf{Ax}$ 平行，即存在常数 $\\lambda, \\mathbf{Ax}=\\lambda\\mathbf{x}.$ $\\mathbf{A}$ 的特征多项式定义为 $p(\\lambda)=\\det{(\\mathbf{A}-\\lambda\\mathbf{I})}.$ $\\mathbf{A}$ 关于某特征值 $\\lambda_1$ 的特征向量是 $(\\mathbf{A}-\\lambda\\mathbf{I})\\mathbf{x=0}$ 的解向量.  \n谱半径：矩阵 $\\mathbf{A}$ 的谱半径 $\\rho(\\mathbf{A})$ 定义为 $\\rho(\\mathbf{A})=\\max{|\\lambda|},\\lambda$ 为 $\\mathbf{A}$ 的一个特征值  \n谱半径与矩阵范数联系紧密：如果 $\\mathbf{A}$ 是一个 $n\\times n$ 矩阵，那么有\n\n$||\\mathbf{A}||_2=\\sqrt{\\rho(\\mathbf{A^TA})}.$\n对于任一自然范数，有 $\\rho(\\mathbf{A})\\le ||\\mathbf{A}||.$  \n\n利用上述性质 1 , 我们可以计算矩阵的从属 $l_2$ 范数.  \n在研究矩阵的迭代方法的过程中，需要知道矩阵的幂何时变小非常重要，此类矩阵被称作收敛的\n矩阵的收敛性：若 $n\\times n$ 的矩阵 $\\mathbf{A}$ 满足：\n\\lim_{k\\to \\infty}(\\mathbf{A}^k)_{ij}=0, (i=1,2\\dots,n;j=1,2\\dots,n ).则该矩阵收敛.\n矩阵的谱半径和其收敛性之间有重要联系，事实上，以下结论等价：\n\n$\\mathbf{A}$ 收敛.\n对于某些自然范数，有 $\\lim_{n\\to\\infty}||\\mathbf{A}^n||=0.$\n对于所有自然范数，有 $\\lim_{n\\to\\infty}||\\mathbf{A}^n||=0.$\n$\\rho(\\mathbf{A})&lt;1.$\n对任意 $\\mathbf{x}$, 有 $\\lim_{n\\to\\infty}\\mathbf{A}^n\\mathbf{x}=\\mathbf{0}.$\n\nSec 3 求解线性方程组的迭代法求解线性方程组的迭代法的基本思路就是先给出解 $\\mathbf{x}$ 的一个初始近似 $\\mathbf{x}^{(0)}$, 接着一系列近似解向量可以通过以下公式求得：\n\\mathbf{x}^{(k)}=\\mathbf{Tx}^{(k-1)}+\\mathbf{c}.$Jacobi$ 迭代：把矩阵 $\\mathbf{A}$ 分解为严格上三角部分 $\\mathbf{U}$, 严格下三角部分 $\\mathbf{L}$ 和对角线部分 $\\mathbf{D}$，有\n\\mathbf{A}=\\mathbf{D-L-U}.方程 $\\mathbf{Ax=b}$，即 $\\mathbf{(D-L-U)x=b}$ 被转换为 $\\mathbf{Dx=(L+U)x+b}$, 即\n\\mathbf{x}=\\mathbf{D}^{-1}\\mathbf{(L+U)x+D}^{-1}\\mathbf{b}.即可得到迭代形式 \\mathbf{x}^{(k)}=[\\mathbf{D}^{-1}\\mathbf{(L+U)]x}^{(k-1)}+[\\mathbf{D}^{-1}\\mathbf{b}].\n即 x_i^{(k)}=\\frac{-\\sum_{j=1,j\\neq i}^n(a_{ij}x^{(k-1)}_j)+b_i}{a_{ii}},i=1,2,\\dots,n.\n$Jacobi$ 迭代可由以下代码实现：int k = 1;while(k&lt;=n)&#123;    for(int i = 1; i &lt;= n; i++)    &#123;        x[i] = (-sum__x+b[i])/a[i][i];    &#125;    if(||x-_x||&lt;TOL) return;    k++;    _x=x;&#125;\n其中 sum__x = $\\sum_{j=1,j\\neq i}^n(a_{ij}x^\\prime_j)$. $Jacobi$ 迭代 要求 $a_{ii}\\neq 0,$ 如果存在 $a_{ii}= 0,$ 可以通过重新排列来解决.\n$Gauss-Seidal$ 迭代：由于在计算 $x^{(k)}_i$ 时，前 $i-1$ 项已经算出来了，并且比 $x^{(k-1)}_1,\\dots,x^{(k-1)}_{i-1}$ 更接近实际解，因此可以进行改进，使用： \nx_i^{(k)}=\\frac{-\\sum_{j=1}^{i-1}(a_{ij}x^{(k)}_j)-\\sum_{j=i+1}^{n}(a_{ij}x^{(k-1)}_j)+b_i}{a_{ii}},i=1,2,\\dots,n.即\n\\mathbf{x}^{(k)}=[\\mathbf{(D-L)}^{-1}\\mathbf{U]x}^{(k-1)}+[\\mathbf{(D-L)}^{-1}\\mathbf{b}].$Gauss-Seidal$ 方法在大多数情况下优于 $Jacobi$ 方法.\n考虑一般迭代方法的收敛性，公式 \n\\mathbf{x}^{(k)}=\\mathbf{Tx}^{(k-1)}+\\mathbf{c}.如果谱半径 $\\rho(\\mathbf{T})&lt;1,$ 那么 $(\\mathbf{I-T})^{-1}$ 存在，且\n(\\mathbf{I-T})^{-1}=\\mathbf{I+T+T^2+\\dots}=\\sum_{j=0}^\\infty \\mathbf{T}^j.对于任意的 $\\mathbf{x}^{(0)}\\in\\mathbf{R}^n$, 由\n\\mathbf{x}^{(k)}=\\mathbf{Tx}^{(k-1)}+\\mathbf{c}.定义的序列收敛到 $\\mathbf{x}=\\mathbf{Tx}+\\mathbf{c}$ 的唯一解 $\\leftrightarrow\\rho(\\mathbf{T})&lt;1.$\n\n证明：假设 $\\rho(\\mathbf{T})&lt;1$, 那么，\\mathbf{x}^{(k)}=\\mathbf{Tx}^{(k-1)}+\\mathbf{c}=\\mathbf{T^2x}^{(k-2)}+\\mathbf{(T+I)c}=\\dots=\\\\\\mathbf{T^kx}^{(0)}+\\mathbf{(\\mathbf{T}^{k-1}+\\dots+T+I)c}\n根据前面的定理，$k\\to\\infty$ 时 $\\mathbf{T}^{k-1}+\\dots+\\mathbf{T+I} = (\\mathbf{I-T})^{-1}.$ 又有，$\\rho(\\mathbf{T})&lt;1$, $\\mathbf{T}$ 收敛， $\\lim_{k\\to\\infty}\\mathbf{T^kx}^{(0)}=0$.\n则有 $\\mathbf{x} = (\\mathbf{I-T})^{-1}\\mathbf{c}.$ 作为 $\\mathbf{x}$ 的唯一解.\n\n如果对任意自然矩阵范数 $||\\mathbf{T}||&lt;1$, 那么由 \\mathbf{x}^{(k)}=\\mathbf{Tx}^{(k-1)}+\\mathbf{c}.\n定义的序列满足以下误差界：\n\n$||\\mathbf{x-x}^{(k)}||\\le ||\\mathbf{T}||^k||\\mathbf{x^{(0)}-x}||.$\n$||\\mathbf{x-x}^{(k)}||\\le \\frac{||\\mathbf{T}||^k}{1-||\\mathbf{T}||}||\\mathbf{x^{(1)}-x^{(0)}}||.$\n\n如果 $\\mathbf{A}$ 是严格对角占优阵，那么对于任选的 $\\mathbf{x}^{(0)}$, $Jacobi$ 和 $Gauss-Seidal$ 迭代法给出的序列都收敛于方程的唯一解.\n可以得出\n||\\mathbf{x^{(k)}-x}||\\approx\\rho(\\mathbf{T}^k)||\\mathbf{x^{(0)}-x}||.因此最好选择谱半径小于 1 的迭代法.\n剩余向量:若 $\\widetilde{x}\\in\\mathbf{R}^n$ 是线性方程组 $\\mathbf{Ax=b}$ 的一个近似解，定义相对于该方程组的 $\\widetilde{x}$ 的剩余向量为 $\\mathbf{r=b-A\\widetilde{x}}.$\n$Gauss-Seidal$ 方法可以重新表示为 x_i^{(k)}=x_i^{(k-1)}+\\frac{r_{ii}^{(k)}}{a_{ii}}.\n我们可以对 $Gauss-Seidal$ 方法进行修改，添加系数 $\\omega$:x_i^{(k)}=x_i^{(k-1)}+\\omega\\frac{r_{ii}^{(k)}}{a_{ii}}.\n可以减少剩余向量的范数并且明显的加速收敛.\n\n$\\omega=1,$ $Gauss-Seidal$ 法\n$0&lt;\\omega&lt;1,$ 低松弛法.\n$1&lt;\\omega,$ 超松弛法.\n这些方法缩写为 $SOR$ 方法.\n\n$SOR$ 方法可以写作矩阵形式：\\mathbf{x}^{(k)}=(\\mathbf{D}-\\omega\\mathbf{L})^{-1}[(1-\\omega)\\mathbf{D}+\\omega\\mathbf{U}]\\mathbf{x}^{(k-1)}+\\omega(\\mathbf{D}-\\omega\\mathbf{L})^{-1}\\mathbf{b}.\n$Kahan$ 定理：如果 $a_{ii}\\neq0$, 那么 $\\rho(\\mathbf{T}_\\omega)\\ge|\\omega-1|,$ 这表明 $SOR$ 方法仅当 $0&lt;\\omega&lt;2$ 时收敛.\n$Ostrowski-Reich$ 定理：若矩阵 $\\mathbf{A}$ 正定, 且 $0&lt;\\omega&lt;2$ , $SOR$ 方法收敛.\n如果矩阵 $\\mathbf{A}$ 是正定三对角阵，$SOR$ 方法的最佳 $\\omega=\\frac2{1+\\sqrt{1-[\\rho(\\mathbf{T}_j)]^2}},$ $\\rho(\\mathbf{T}_\\omega)=\\omega-1$\n\nChap8 : 逼近论Sec 1 离散最小二乘逼近线性最小二乘逼近：给定 $n$ 个数据点 $(x_1,y_1),(x_2,y_2),…(x_n,y_n)$ 寻找其最佳线性逼近方程的问题就是找到 $a_0$ 和 $a_1$ 使得\nE_2(a_0,a_1)=\\sum_{i =1}^{n}[y_i-(a_1x_i+a_0)]^2达到最小值，即最小二乘逼近.   \n为了确定 $a_0$ 和 $a_1$，解方程：\n\\frac\\partial{\\partial a_0}\\sum_{i =1}^{n}[y_i-(a_1x_i+a_0)]^2=0和\n\\frac\\partial{\\partial a_1}\\sum_{i =1}^{n}[y_i-(a_1x_i+a_0)]^2=0可得解为：\na_0=\\frac{\\sum_{i=1}^nx_i^2\\sum_{i=1}^ny_i-\\sum_{i=1}^nx_iy_i\\sum_{i=1}^nx_i}{n(\\sum_{i=1}^nx_i^2)-(\\sum_{i=1}^nx_i)^2}和\na_1=\\frac{n\\sum_{i=1}^nx_iy_i-\\sum_{i=1}^nx_i\\sum_{i=1}^ny_i}{n(\\sum_{i=1}^nx_i^2)-(\\sum_{i=1}^nx_i)^2}更高阶的最小二乘逼近：考虑 $n$ 阶多项式 $P_n(x)=a_nx^n+a_{n-1}x^{n-1}+…+a_1x+a_0$,有 \nE_2=\\sum_{i=1}^m(y_i-P_n(x_i))^2类似于求解线性最小二乘逼近的过程，我们可以得到 $n+1$ 个方程，可以解出唯一的一组 $\\{a_0,a_1,…a_n\\}$：\n\\sum_{k=0}^na_k\\sum_{i=1}^mx_i^{j+k}=\\sum_{i=1}^my_ix_i^j,j=0,1,...n可以写成以下矩阵形式：\n\\begin{bmatrix}\n    m    & \\sum_{i=1}^mx_i & \\sum_{i=1}^mx_i^2 & \\dots & \\sum_{i=1}^mx_i^n \\\\\n    \\sum_{i=1}^mx_i    & \\sum_{i=1}^mx_i^2 & \\sum_{i=1}^mx_i^3 & \\dots & \\sum_{i=1}^mx_i^{n+1} \\\\\n    \\dots & \\dots & \\dots & \\dots & \\dots    \\\\\n    \\sum_{i=1}^mx_i^n  & \\sum_{i=1}^mx_i^{n+1} & \\sum_{i=1}^mx_i^{n+2} & \\dots & \\sum_{i=1}^mx_i^{2n}\n\\end{bmatrix}\n\\begin{bmatrix}\n    a_0\\\\\n    a_1\\\\\n    \\dots\\\\\n    a_n \n\\end{bmatrix}=\\\\\n\\begin{bmatrix}\n    \\sum_{i=1}^my_i\\\\\n    \\sum_{i=1}^my_ix_i\\\\\n    \\dots\\\\\n    \\sum_{i=1}^my_ix_i^n\n\\end{bmatrix}指数的最小二乘逼近：考虑逼近函数的以下形式\ny=be^{ax},y=bx^a此时可以对方程两边求对数，得到\n\\ln{y}=\\ln{b}+ax,\\ln y=\\ln b + a\\ln x从而将其转化为线性的最小二乘逼近.\nSec 2 正交多项式和(连续的)最小二乘逼近考虑区间 $[a,b]$ 上函数 $f$ ，需要一个多项式 $P_n(x)$ 来使得误差\nE=\\int_a^b[f(x)-P_n(x)]^2dx达到最小值，类似于 C8P1 中对高阶多项式最小二乘逼近的解，我们有\n\\sum_{k=0}^na_k\\int^b_ax^{j+k}dx=\\sum_a^bx^jf(x)dx例如，对于 $f(x)=\\sin {\\pi x}$ 在区间 $[0,1]$ 上的最小二乘逼近多项式，有\na_0\\int_0^11dx+a_1\\int^1_0xdx+a_2\\int^1_0x^2dx=\\int^1_0\\sin {\\pi x}dxa_0\\int_0^x1dx+a_1\\int^1_0x^2dx+a_2\\int^1_0x^3dx=\\int^1_0x\\sin {\\pi x}dxa_0\\int_0^1x^2dx+a_1\\int^1_0x^3dx+a_2\\int^1_0x^4dx=\\int^1_0x^2\\sin {\\pi x}dx注意到\n\\int_a^bx^{j+k}dx=\\frac{b^{j+k+1}-a^{j+k+1}}{j+k+1}这一线性方程组的数值解难以求出，因为其是 $Hilbert$ 矩阵. 一种改进的方法是利用正交多项式。\n\n对于所有的 $j \\ge 0$, 如果 $\\phi _j(x)$ 为一个 $j$ 阶多项式，那么 $\\{\\phi_0,\\phi_1,…,\\phi_n\\}$ 在任意区间上线性无关。\n\n权函数：若可积函数对区间 $I$ 中所有的 $x$ 都有 $w(x)\\ge 0$ 且 $\\exists u\\in I, w(u)\\neq0$ 那么 $w(x)$ 是区间 $I$ 上的一个权函数。  \n假设 $\\{\\phi_0,\\phi_1,…,\\phi_n\\}$ 是某区间 $[a,b]$ 上一组线性无关的函数集合，$w$ 是区间 $[a,b]$ 上的一个权函数，对某函数 $f(x)$ 的一个逼近定义为：\nP(x)=\\sum_{k=0}^na_k\\phi_k(x)来使得误差\nE=\\int_a^bw(x)[f(x)-\\sum_{k=0}^na_k\\phi_k(x)]^2dx达到最小值. 对每一个 $a_j$ 求偏导有：\n\\int_a^bw(x)[f(x)-\\sum_{k=0}^na_k\\phi_k(x)]\\phi_j(x)dx = 0移项可以得到：\n\\int_a^bw(x)f(x)\\phi_j(x)dx=\\sum_{k=0}^{n}a_k\\int_a^bw(x)\\phi_k(x)\\phi_j(x)dx若选择好的 $\\{\\phi_0,\\phi_1,…,\\phi_n\\}$ ，使得 $\\phi_k(x)$ 与 $\\phi_j(x)$ 对于权函数 $w(x)$ 标准正交，即\n\\int_a^bw(x)\\phi_k(x)\\phi_j(x)dx=\\left\\{\n\\begin{aligned}\n0,&  j\\neq k\\\\\nC>0,  &j=k\n\\end{aligned}\n\\right.求解 $a_j$ 变得容易：\na_j=\\frac{\\int^b_aw(x)f(x)\\phi_j(x)dx}{\\int^b_aw(x)[\\phi_j(x)]^2dx}为了得到标准正交的多项式集合，引入 $Gram-Schmidt$ 方法。令：\n\\phi_0(x)\\equiv1,\\phi_1(x)=x-B_1,\\phi_2(x)=(x-B_2)\\phi_1(x)-C_2\\phi_0(x),\\dots\\phi_n(x)=(x-B_n)\\phi_{n-1}(x)-C_n\\phi_{n-2}(x),其中,\nB_n=\\frac{\\int^b_axw(x)[\\phi_{n-1}(x)]^2dx}{\\int^b_aw(x)[\\phi_{n-1}(x)]^2dx},C_n=\\frac{\\int^b_axw(x)\\phi_{n-1}(x)\\phi_{n-2}(x)dx}{\\int^b_aw(x)[\\phi_{n-2}(x)]^2dx}.Sec 3 $Chebyshev$ 多项式和幂级数的缩减$Chebyshev$ 多项式由以下定义给出：\nT_n(x)=\\cos {(n\\arccos{x})}.注意到 $T_0(x)=1, T_1(x)=x.$  \n做变量替换 $\\theta=\\arccos x$ 可得\nT_{n+1}(\\theta)=\\cos{(n\\theta)}\\cos\\theta-\\sin{(n\\theta)}\\sin\\theta,T_{n-1}(\\theta)=\\cos{(n\\theta)}\\cos\\theta+\\sin{(n\\theta)}\\sin\\theta.进而：\nT_{n+1}(x)=2xT_n(x)-T_{n-1}(x)因此，$T_n(x)$ 为一个首项系数为 $2^{n-1}$ 的 $n$ 阶多项式。  \n$Chebyshev$ 多项式在区间 $(-1,1)$ 上关于权函数 $w(x) = \\frac1{\\sqrt{1-x^2}}$ 正交，且：\n\\int^1_{-1}\\frac{[T_n(x)]^2}{\\sqrt{1-x^2}}dx=\\frac\\pi2$n$ 阶 $Chebyshev$ 多项式 $T_n(x)$ 在区间 $[-1,1]$ 上有 $n$ 个零点\nx_k = cos(\\frac{2k-1}{2n}\\pi).且，$T_n(x)$ 的绝对极点值在\nx_k^{'}=cos(\\frac{k\\pi}n), T_n(x_k^{'})=(-1)^k.首1 $Chebyshev$ 多项式 $\\widetilde{T}_n(x)$ 由 $Chebyshev$ 多项式除以 $2^{n-1}$ 得到. 其最高项系数为1.  \n假设 $\\widetilde{\\prod}_n$ 为所有 $n$ 阶首1多项式的集合，$P_n(x)\\in\\widetilde{\\prod}_n$ 那么有：\n\\frac1{2^{n-1}}=\\max_{x\\in[-1,1]}{|\\widetilde{T}_n(x)|}\\le\\max_{x\\in[-1,1]}{|P_n(x)|}等号当且仅当 $P_n(x)\\equiv\\widetilde{T}_n$ 时成立.  \n假设 $P(x)$ 为区间 $[-1,1]$ 上的一个 $Lagrange$ 插值,注意到\nf(x)-P(x)=\\frac{f^{(n+1)}(\\xi(x))}{(n+1)!}(x-x_0)(x-x_1)\\dots(x-x_n).$Chebyshev$ 多项式可以使近似误差达到最小。  \n我们可以通过插值点的选择来优化 $\\prod_{i=0}^{n}(x-x_i)$ 使误差达到最小，又由于首1 $Chebyshev$ 多项式的性质，当\n\\prod_{i=0}^{n}(x-x_i)=\\widetilde{T}_{n+1}(x).时，该项达到最小。  \n因此，当 $x_k$ 选择为 $\\widetilde{T}_{n+1}$ 的第 $k+1$ 个零点时，$\\prod_{i=0}^{n}(x-x_i)$ 构成首1 $Chebyshev$ 多项式，逼近误差达到最小. 即：\n\\max_{x\\in[-1,1]}|f(x)-P(x)|\\le\\frac1{2^n(n+1)!}\\max_{x\\in[-1,1]}|f^{(n+1)}(x)|由于变量替换 $\\widetilde{x}=\\frac12[(b-a)x+a+b]$ , $Chebyshev$ 多项式可以扩展到任意的区间 $[a,b]$ 上。  \n另外，$Chebyshev$ 多项式可以用来在精度损失最小的情况下降低逼近多项式的阶。  \n考虑在区间 $[-1,1]$ 上的某 $n$ 阶多项式 $P_n(x)$ 作为逼近，目标是在 $\\prod_{n-1}$ 中选取 $P_{n-1}(x)$ 使得：\n\\max_{x\\in[-1,1]}|P_n(x)-P_{n-1}(x)|.尽量小.  \n由上一部分给出的定理可以知道：\n\\max_{x\\in[-1,1]}|\\frac{1}{a_n}(P_n(x)-P_{n-1}(x))|\\ge \\frac1{2^{n-1}}.当且仅当：\n\\frac{1}{a_n}(P_n(x)-P_{n-1}(x))=\\widetilde{T}_n(x).那么：\nP_{n-1}(x)=P_{n}(x)-a_n\\widetilde{T}_n(x).最小值为 $\\frac{|a_n|}{2^{n-1}}.$\n\nChap 9 : 逼近特征值Sec 2 幂法幂法是用来确定矩阵的主特征值的一种迭代方法。他可以生成绝对值最大的特征值及其特征向量.\n假设 $n\\times n$ 矩阵 $\\mathbf{A}$ 有 $n$ 个特征值 $\\lambda_1,\\lambda_2,\\dots,\\lambda_n$ 与相应的线性无关的特征向量集合 $\\{\\mathbf{v}^{(1)},\\mathbf{v}^{(2)},\\dots,\\mathbf{v}^{(n)}\\}$，假设 $\\mathbf{A}$ 的最大绝对值的特征值为 $\\lambda_1$. \n假设 $\\mathbf{x}$ 为某向量， $\\{\\mathbf{v}^{(1)},\\mathbf{v}^{(2)},\\dots,\\mathbf{v}^{(n)}\\}$ 线性无关，即有常数 $\\beta_1,\\beta_2,\\dots,\\beta_n$ 满足 \\mathbf{x}=\\sum_{j=1}^n\\beta_j\\mathbf{v}^{(j)}.\n两边同乘 $\\mathbf{A},\\mathbf{A}^2,\\dots,\\mathbf{A}^k$ 可得：\n\\mathbf{Ax}=\\sum_{j=1}^n\\beta_j\\mathbf{Av}^{(j)}=\\sum_{j=1}^n\\beta_j\\lambda_j\\mathbf{v}^{(j)},\\mathbf{A^2x}=\\sum_{j=1}^n\\beta_j\\mathbf{A^2v}^{(j)}=\\sum_{j=1}^n\\beta_j\\lambda_j^2\\mathbf{v}^{(j)},\\dots\\mathbf{A^kx}=\\sum_{j=1}^n\\beta_j\\lambda_j^k\\mathbf{v}^{(j)}.\\mathbf{A^kx}=\\lambda_1^k\\sum_{j=1}^n\\beta_j(\\frac{\\lambda_j}{\\lambda_1})^k\\mathbf{v}^{(j)}.当 $k\\to\\infty, \\lim_{k\\to\\infty}\\mathbf{A^kx}=\\lim_{k\\to\\infty}\\lambda_1^k\\beta_1\\mathbf{v}^{(1)}$… 然后就没写了\n"}]